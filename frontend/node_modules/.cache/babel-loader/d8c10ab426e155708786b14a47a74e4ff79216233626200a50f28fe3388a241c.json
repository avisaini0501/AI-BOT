{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createApiCall = void 0;\n/**\n * Provides function wrappers that implement page streaming and retrying.\n */\nconst apiCaller_1 = require(\"./apiCaller\");\nconst retries_1 = require(\"./normalCalls/retries\");\nconst timeout_1 = require(\"./normalCalls/timeout\");\n/**\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promise to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * @param {Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make\n *   a bare RPC call, or just a bare RPC call.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Descriptor} descriptor - optionally specify the descriptor for\n *   the method call.\n * @return {GaxCall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\nfunction createApiCall(func, settings, descriptor,\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_fallback // unused here, used in fallback.ts implementation\n) {\n  // we want to be able to accept both promise resolving to a function and a\n  // function. Currently client librares are only calling this method with a\n  // promise, but it will change.\n  const funcPromise = typeof func === 'function' ? Promise.resolve(func) : func;\n  // the following apiCaller will be used for all calls of this function...\n  const apiCaller = (0, apiCaller_1.createAPICaller)(settings, descriptor);\n  return (request, callOptions, callback) => {\n    const thisSettings = settings.merge(callOptions);\n    let currentApiCaller = apiCaller;\n    // special case: if bundling is disabled for this one call,\n    // use default API caller instead\n    if (settings.isBundling && !thisSettings.isBundling) {\n      currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\n    }\n    const ongoingCall = currentApiCaller.init(callback);\n    funcPromise.then(func => {\n      var _a;\n      // Initially, the function is just what gRPC server stub contains.\n      func = currentApiCaller.wrap(func);\n      const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\n      const retry = thisSettings.retry;\n      if (!streaming && retry && retry.retryCodes && retry.retryCodes.length > 0) {\n        retry.backoffSettings.initialRpcTimeoutMillis = retry.backoffSettings.initialRpcTimeoutMillis || thisSettings.timeout;\n        return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\n      }\n      return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\n    }).then(apiCall => {\n      // After adding retries / timeouts, the call function becomes simpler:\n      // it only accepts request and callback.\n      currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\n    }).catch(err => {\n      currentApiCaller.fail(ongoingCall, err);\n    });\n    // Calls normally return a \"cancellable promise\" that can be used to `await` for the actual result,\n    // or to cancel the ongoing call.\n    return currentApiCaller.result(ongoingCall);\n  };\n}\nexports.createApiCall = createApiCall;","map":{"version":3,"names":["Object","defineProperty","exports","value","createApiCall","apiCaller_1","require","retries_1","timeout_1","func","settings","descriptor","_fallback","funcPromise","Promise","resolve","apiCaller","createAPICaller","request","callOptions","callback","thisSettings","merge","currentApiCaller","isBundling","undefined","ongoingCall","init","then","_a","wrap","streaming","retry","retryCodes","length","backoffSettings","initialRpcTimeoutMillis","timeout","retryable","otherArgs","apiName","addTimeoutArg","apiCall","call","catch","err","fail","result"],"sources":["C:/Users/Lenovo/Desktop/clone/node_modules/google-gax/build/src/createApiCall.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createApiCall = void 0;\n/**\n * Provides function wrappers that implement page streaming and retrying.\n */\nconst apiCaller_1 = require(\"./apiCaller\");\nconst retries_1 = require(\"./normalCalls/retries\");\nconst timeout_1 = require(\"./normalCalls/timeout\");\n/**\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promise to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * @param {Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make\n *   a bare RPC call, or just a bare RPC call.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Descriptor} descriptor - optionally specify the descriptor for\n *   the method call.\n * @return {GaxCall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\nfunction createApiCall(func, settings, descriptor, \n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_fallback // unused here, used in fallback.ts implementation\n) {\n    // we want to be able to accept both promise resolving to a function and a\n    // function. Currently client librares are only calling this method with a\n    // promise, but it will change.\n    const funcPromise = typeof func === 'function' ? Promise.resolve(func) : func;\n    // the following apiCaller will be used for all calls of this function...\n    const apiCaller = (0, apiCaller_1.createAPICaller)(settings, descriptor);\n    return (request, callOptions, callback) => {\n        const thisSettings = settings.merge(callOptions);\n        let currentApiCaller = apiCaller;\n        // special case: if bundling is disabled for this one call,\n        // use default API caller instead\n        if (settings.isBundling && !thisSettings.isBundling) {\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\n        }\n        const ongoingCall = currentApiCaller.init(callback);\n        funcPromise\n            .then((func) => {\n            var _a;\n            // Initially, the function is just what gRPC server stub contains.\n            func = currentApiCaller.wrap(func);\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\n            const retry = thisSettings.retry;\n            if (!streaming &&\n                retry &&\n                retry.retryCodes &&\n                retry.retryCodes.length > 0) {\n                retry.backoffSettings.initialRpcTimeoutMillis =\n                    retry.backoffSettings.initialRpcTimeoutMillis ||\n                        thisSettings.timeout;\n                return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\n            }\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\n        })\n            .then((apiCall) => {\n            // After adding retries / timeouts, the call function becomes simpler:\n            // it only accepts request and callback.\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\n        })\n            .catch(err => {\n            currentApiCaller.fail(ongoingCall, err);\n        });\n        // Calls normally return a \"cancellable promise\" that can be used to `await` for the actual result,\n        // or to cancel the ongoing call.\n        return currentApiCaller.result(ongoingCall);\n    };\n}\nexports.createApiCall = createApiCall;\n//# sourceMappingURL=createApiCall.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}